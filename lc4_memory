/************************************************************************/
/* File Name : lc4_memory.c		 										*/
/* Purpose   : This file implements the linked_list helper functions	*/
/* 			   to manage the LC4 memory									*/
/*             															*/
    /* Author(s) : 								*/
/************************************************************************/

#include <stdio.h>
#include "lc4_memory.h"
#include "lc4_disassembler.h"
#include <stdlib.h>

/*
 * adds a new node to a linked list pointed to by head
 */
int add_to_list(row_of_memory** head, short unsigned int address, short unsigned int contents) {
    
    row_of_memory** place_searcher = head; // Renamed "beginning" to "place_searcher"
    
    /* check to see if there is already an entry for this address and update the contents, if so */
    
    row_of_memory* pointer = NULL;
    
    if (head != NULL && *head != NULL) {
        pointer = search_address(*head, address);
    }
    
    if (pointer != NULL) {
        pointer->contents = contents;
        return 0; // If address was found, return success immediately
    }
    
    /* allocate memory for a single node */
    
    row_of_memory* new_node = malloc(sizeof(row_of_memory)); 
    
    if (new_node == NULL) {
        printf("error-1: could not allocate memory space \n");
        return -1;
    } 
    
    /* populate fields in newly allocated node with address and contents */
    
    new_node->address = address;
    new_node->label = NULL;
    new_node->contents = contents;
    new_node->assembly = NULL;
    new_node->next = NULL;
      
    /* if head==NULL, node created is the new head of the list! */
    
    if (head == NULL || *head == NULL) { // Simplified condition
        *head = new_node;
        return 0;
    }
    
    /* otherwise, insert node into the list in address ascending order */
    
    row_of_memory* follower = *head;
    row_of_memory* predecessor = NULL;
    
    while (follower != NULL && address > follower->address) {
        predecessor = follower;
        follower = follower->next;
    }
    
    if (predecessor == NULL) { // If new node is at the beginning of the list
        new_node->next = *head;
        *head = new_node; 
    }
    else {
        predecessor->next = new_node;
        new_node->next = follower;
    }
      
    /* return 0 for success, -1 if malloc fails */
    return 0;
}
/*
 * search linked list by address field, returns node if found
 */
row_of_memory* search_address (row_of_memory* head, short unsigned int address ) { 
	
    /* traverse linked list, searching each node for "address"  */

	/* return pointer to node in the list if item is found */

	/* return NULL if list is empty or if "address" isn't found */
 
    row_of_memory** beginning = &head;
    
    row_of_memory* pointer = NULL;
    
    while ( (beginning!= NULL)||(*beginning !=NULL) ){
        
        if ((*beginning)->address == address){
            pointer = *beginning;
            
            return (pointer);
        }
        
        row_of_memory* after = (*beginning)->next;
        
        if (after == NULL){ 
            
            pointer = NULL; 
            return (pointer);}
        
        else {beginning = &after;}   
         
    }
 
 return(pointer);

}

/*
 * search linked list by opcode field, returns node if found
 */
row_of_memory* search_opcode  (row_of_memory* head, short unsigned int opcode ) {
    /* opcode parameter is in the least significant 4 bits of the short int and ranges from 0-15 */
    
    /* traverse linked list until node is found with matching opcode
	   AND "assembly" field of node is empty */
    row_of_memory* start = head;
    
    row_of_memory* ptr =  head;
    
    short unsigned int code = -2;
    
   
    while (ptr != NULL){
        code = read_opcode(ptr);
        if (code == 25) {return NULL;}
        else {
        if ((code == opcode) && (ptr -> assembly == NULL)){break;}  
        ptr = ptr -> next;}
        }
   
    printf ("opcode is %d \n", read_opcode(ptr));
    head = start;

	/* return pointer to node in the list if item is found */

	/* return NULL if list is empty or if no matching nodes */

	return ptr ;
}


void print_list (row_of_memory* head ){
	
    /* make sure head isn't NULL */
    if (head == NULL){
        printf("Sorry nothing to print\n");
        return;
    }
                      
	/* print out a header */
    printf("<label> \t <address> \t <contents> \t <assembly>\n");
    
    /* don't print assembly directives for non opcode 1 instructions if you are doing extra credit */

	/* traverse linked list, print contents of each node */
    row_of_memory* pointer = head;
    
    while (pointer != NULL){
        if ((*pointer).label != NULL){printf("%-20s", (*pointer).label);}
        else {printf("%-20s"," ");}
        if (pointer-> address != 0){printf("0x%04X \t", pointer-> address);}
        else {printf("0x0000 \t");}
        if (pointer ->contents!= 0){printf("0x%04X \t\t", pointer ->contents);}
        else {printf("    \t\t\t");}
        if (pointer -> assembly != NULL){printf("%s \n", pointer -> assembly);}
        else {printf("   \t\t\t \n");}
                                                
        pointer = pointer ->  next;
    }  
    

	return ;
}

/*
 * delete entire linked list
 */
int delete_list (row_of_memory** head ) {
    
	row_of_memory** beginning = head;
    row_of_memory** tracker = head;
    
    row_of_memory* alpha;
    row_of_memory* beta;
    row_of_memory* gamma;
   
    while ((*tracker)->next != NULL){
               
        alpha = *tracker;
        beta = alpha ->next;
        gamma = beta -> next;
   
        while (gamma !=NULL){
            alpha = beta,
            beta = gamma,
            gamma = gamma -> next;
              
        }

        tracker = &beta;
        free ((*tracker)->label);
        free ((*tracker)->assembly);
        free(*tracker);  
       
        *tracker = NULL;
        alpha -> next = NULL;
        head = beginning;
        tracker = head;
        }
    
    free ((*head)->label);
    free ((*head)->assembly);
    free(*head);

	/* return 0 if no error, -1 for any errors that may arise */
	return 0 ;
}


short unsigned int read_opcode (row_of_memory* node){
    
    if (node == NULL){ return 25;}
    else {
    short unsigned int content = node -> contents;
    
    short unsigned int result = 0;
    
    int* binary_instruction= malloc (16 * sizeof(int)) ;
    binary_instruction = convert (content);
    
   
    result = binary_instruction[15]*8 + binary_instruction[14]*4 + binary_instruction[13]*2 + binary_instruction[12] ;
    
    free (binary_instruction);
    
    return result;}
}
